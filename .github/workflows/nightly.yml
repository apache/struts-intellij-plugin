# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements. See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License. You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Nightly workflow for building and publishing pre-release plugin versions.
#
# Runs on a daily schedule (2:00 AM UTC) and checks if there are new commits
# since the last pre-release. If changes are detected (or triggered manually),
# it builds the plugin and publishes to the JetBrains Marketplace nightly channel
# and creates a GitHub pre-release.

name: Nightly
on:
  schedule:
    - cron: '0 2 * * *'
  workflow_dispatch:

jobs:

  # Check if there are new commits since the last pre-release
  check-changes:
    name: Check for changes
    runs-on: ubuntu-latest
    outputs:
      has_changes: ${{ steps.check.outputs.has_changes }}
    permissions:
      contents: read
    steps:

      - name: Fetch Sources
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Check for new commits
        id: check
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Fetch the tag from the latest GitHub pre-release
          LATEST_TAG=$(gh release list --limit 50 --json tagName,isPrerelease \
            --jq '.[] | select(.isPrerelease == true) | .tagName | select(contains("nightly"))' | head -1)

          if [ -z "$LATEST_TAG" ]; then
            # No previous pre-release exists ‚Äî first run, always build
            echo "No previous pre-release found, will build"
            echo "has_changes=true" >> $GITHUB_OUTPUT
          else
            # Count commits between last pre-release tag and HEAD
            COUNT=$(git rev-list "${LATEST_TAG}..HEAD" --count 2>/dev/null || echo "999")
            echo "Commits since ${LATEST_TAG}: ${COUNT}"
            if [ "$COUNT" -gt 0 ]; then
              echo "has_changes=true" >> $GITHUB_OUTPUT
            else
              echo "has_changes=false" >> $GITHUB_OUTPUT
            fi
          fi

  # Build and publish nightly pre-release
  nightly-release:
    name: Nightly release
    needs: [ check-changes ]
    if: needs.check-changes.outputs.has_changes == 'true' || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:

      # Check out the current repository
      - name: Fetch Sources
        uses: actions/checkout@v6

      # Set up Java environment
      - name: Setup Java
        uses: actions/setup-java@v5
        with:
          distribution: zulu
          java-version: 21

      # Setup Gradle
      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v5
        with:
          gradle-home-cache-cleanup: true

      # Generate version for pre-release
      - name: Generate Version
        id: version
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get branch number from pluginVersion prefix (e.g., "253" from "253.18970.1")
          BRANCH=$(grep "pluginVersion" gradle.properties | cut -d '=' -f2 | cut -d '.' -f1 | tr -d ' ')

          # Get the latest release version to determine next build number
          LATEST_RELEASE=$(gh release list --limit 1 --exclude-pre-releases --json tagName --jq '.[0].tagName')
          LATEST_BUILD=$(echo "$LATEST_RELEASE" | sed 's/v[0-9]*\.\([0-9]*\)\.[0-9]*/\1/')

          # Increment build number for nightly builds
          BUILD=$((LATEST_BUILD + 1))

          # Find latest pre-release nightly counter to avoid version collisions
          LATEST_NIGHTLY=$(gh release list --limit 50 --json tagName,isPrerelease \
            --jq '.[] | select(.isPrerelease == true) | .tagName | select(contains("nightly"))' | head -1)

          if echo "$LATEST_NIGHTLY" | grep -q "nightly"; then
            NIGHTLY_NUM=$(echo "$LATEST_NIGHTLY" | sed 's/.*-nightly\.\([0-9]*\)/\1/')
            NIGHTLY_NUM=$((NIGHTLY_NUM + 1))
          else
            NIGHTLY_NUM=1
          fi

          # Update pluginVersion in gradle.properties
          sed -i "s/pluginVersion = [0-9]*\.[0-9]*\.[0-9]*/pluginVersion = ${BRANCH}.${BUILD}-nightly.${NIGHTLY_NUM}/" gradle.properties

          # Get final version and changelog
          PROPERTIES="$(./gradlew properties --no-configuration-cache --console=plain -q)"
          VERSION="$(echo "$PROPERTIES" | grep "^version:" | cut -f2- -d ' ')"
          CHANGELOG="$(./gradlew getChangelog --no-configuration-cache --unreleased --no-header --console=plain -q)"

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # Build plugin with new version
      - name: Build Plugin
        run: ./gradlew buildPlugin --no-configuration-cache

      # Publish pre-release to JetBrains Marketplace nightly channel
      - name: Publish Plugin to Marketplace (Nightly)
        env:
          PUBLISH_TOKEN: ${{ secrets.PUBLISH_TOKEN }}
          CERTIFICATE_CHAIN: ${{ secrets.CERTIFICATE_CHAIN }}
          PRIVATE_KEY: ${{ secrets.PRIVATE_KEY }}
          PRIVATE_KEY_PASSWORD: ${{ secrets.PRIVATE_KEY_PASSWORD }}
        run: ./gradlew publishPlugin --no-configuration-cache

      # Prepare plugin archive content for creating artifact
      - name: Prepare Plugin Artifact
        id: artifact
        shell: bash
        run: |
          cd ${{ github.workspace }}/build/distributions
          FILENAME=$(ls *-signed.zip 2>/dev/null || ls *.zip | head -1)
          unzip "$FILENAME" -d content

          # Use the version-based filename for artifact
          echo "filename=struts-intellij-plugin-v${{ steps.version.outputs.version }}" >> $GITHUB_OUTPUT

      # Store already-built plugin as an artifact for downloading
      - name: Upload artifact
        uses: actions/upload-artifact@v6
        with:
          name: ${{ steps.artifact.outputs.filename }}
          path: ./build/distributions/content/*/*

      # Delete previous pre-release if it exists
      - name: Delete Previous Pre-release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get the latest pre-release (excluding the current version we're about to create)
          LATEST_PRERELEASE=$(gh release list --limit 50 --json tagName,isPrerelease --jq '.[] | select(.isPrerelease == true) | .tagName | select(contains("nightly"))' | head -1 2>/dev/null || echo "")

          if [ -n "$LATEST_PRERELEASE" ] && [ "$LATEST_PRERELEASE" != "v${{ steps.version.outputs.version }}" ]; then
            echo "Deleting previous pre-release: $LATEST_PRERELEASE"
            gh release delete "$LATEST_PRERELEASE" --yes --cleanup-tag
          else
            echo "No previous pre-release found to delete"
          fi

      # Create a new pre-release
      - name: Create Pre-release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          CHANGELOG: ${{ steps.version.outputs.changelog }}
        run: |
          # Find the plugin zip file
          PLUGIN_ZIP=$(find ./build/distributions -name "*-signed.zip" -type f | head -1)
          [ -z "$PLUGIN_ZIP" ] && PLUGIN_ZIP=$(find ./build/distributions -name "*.zip" -type f | head -1)

          NOTES="üöÄ **Nightly build v${{ steps.version.outputs.version }}**

          This is an automated nightly build from the main branch.

          ## Changes
          ${CHANGELOG}

          ## Installation
          Download the plugin zip file and install it manually in IntelliJ IDEA via:
          \`Settings ‚Üí Plugins ‚Üí ‚öôÔ∏è ‚Üí Install Plugin from Disk...\`"

          gh release create "v${{ steps.version.outputs.version }}" \
            --prerelease \
            --title "v${{ steps.version.outputs.version }}" \
            --notes "$NOTES" \
            "$PLUGIN_ZIP"
